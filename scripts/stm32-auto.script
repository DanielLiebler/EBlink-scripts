//! STmicro
/////////////////////////////////////////////////////
//
//            STmicro cortex-M devices
//
//     The script tries to detect the right memory sizes
//     however, if this is not correct you can set the sizes
//     in kilobytes on the command line as:
//
//         -D FLASH_SIZE=xxx  and -D RAM_SIZE=xxxx
//
//     Fix chip_id for F4 rev A errata , Read CPU ID, as CoreID is the same for F2/F4 - 0x411
//     so we have 0x411 also as a cortex-M4 in the list (see patch).
//

STMICRO <- [
["M0+", [["stmicro/stm32l0x.script", [ 0x417, 0x425, 0x447, 0x457 ]],
         ["stmicro/stm32gx.script",  [ 0x466, 0x456, 0x460, 0x467 ]],
         ["stmicro/stm32C0x.script", [ 0x443, 0x453 ]]]],
["M0",  [["stmicro/stm32f0x.script", [ 0x440, 0x442, 0x444, 0x445, 0x448 ]]]],
["M3",  [["stmicro/stm32f1x.script", [ 0x410, 0x412, 0x414, 0x418, 0x420, 0x428, 0x430 ]],
         ["stmicro/stm32f2x.script", [ 0x411 ]],
         ["stmicro/stm32l1x.script", [ 0x416, 0x427, 0x429, 0x436, 0x437 ]]]],
["M4",  [["stmicro/stm32f4x.script", [ 0x413, 0x419, 0x421, 0x423, 0x431, 0x433, 0x434, 0x441, 0x458, 0x411 /*patch*/ ]],
         ["stmicro/stm32f3x.script", [ 0x422, 0x432, 0x438, 0x439, 0x446 ]],
         ["stmicro/stm32l4x.script", [ 0x415, 0x435, 0x461, 0x462, 0x464, 0x470, 0x471 ]],
         ["stmicro/stm32gx.script",  [ 0x468, 0x469, 0x479 ]],
         ["stmicro/stm32wxxx.script",[ 0x495, 0x496, 0x497 ]]]],
["M7",  [["stmicro/stm32f7x.script", [ 0x449, 0x451, 0x452 ]],
         ["stmicro/stm32h7x.script", [ 0x450, 0x480, 0x483 ]]]],
["M33", [["stmicro/stm32u5x.script", [ 0x455, 0x476, 0x481, 0x482 ]],
         ["stmicro/stm32l5x.script", [ 0x472 ]],
         ["stmicro/stm32h5x.script", [ 0x484 ]]]]
]


intrfApi <- InterfAPI()  // Global so that all included script files also have access
targetApi<- TargetAPI()  // Global interface to the target class
deviceId <- 0            // Global deviceId

// Used by script to denote a not found devcie
const ERROR_NOT_FOUND -100

/////////////////////////////////////////////////////
//
//  EBlink called Entry point
//
function main()
{
    try{
        findDevice()
    }
    catch(e)
    {
        if( e == ERROR_NOT_FOUND)
            if(deviceId)
            {
                printf("\n\nPlease report this ID so that we can add it.\n")
                errorf("Error unsupported STM32 ID: 0x%X\n", deviceId)
            }
            else
                errorf("ERROR: No valid STmicro device ID found\n")
        else
            errorf("Error:\tCan't access target device!\n\tIf reset is disabled (\"dr\" option), try with reset.")
        return ERROR_NOTIFIED  // We have already thrown an error so use -1 (otherwise < -1)
    }
    return ERROR_OK
}

/////////////////////////////////////////////////////
//
//
//
function findDevice()
{
    // Check if the right script API is supported
    if( VERSION < 5.0)
    {
       errorf("Error:\n\nIncompatiable EBlink version %.1f\n\tPlease update\n", VERSION)
       throw ERROR_NOTIFIED
    }

    // Default device ID register
  local result = intrfApi.readMem32(0xE0042000)

    //Otherwise.. try Corex M0 DBGMCU_IDCODE register address
    if( (result < 0) || (intrfApi.value32 == 0) )
        result = intrfApi.readMem32(0x40015800)

    //Otherwise.. Perhaps H7
    if( (result < 0) || (intrfApi.value32 == 0) )
        result = intrfApi.readMem32(0x5C001000)

    //Otherwise.. Perhaps L5
    if( (result < 0) || (intrfApi.value32 == 0) )
        result = intrfApi.readMem32(0xE0044000)

     //Otherwise.. Perhaps H5
    if( (result < 0) || (intrfApi.value32 == 0) )
        result = intrfApi.readMem32(0x44024000)

    //Set our global device ID
    deviceId = intrfApi.value32

    if(deviceId == 0)
        throw ERROR_NOT_FOUND

    // We have a device id, try to find a device with it
    dev_lookup()
}

/////////////////////////////////////////////////////
//
//
//
function dev_lookup()
{
    deviceId = deviceId & 0xfff
    noticef("STmicro device : 0x%X\n", deviceId)

    // Search our device ID in the list and load/execute corresponding device script
    local targetName = targetApi.getCpuName()
    for (local i=0;i<STMICRO.len();i++)
      if(STMICRO[i][0] == targetName)
      {
          local devs = STMICRO[i][1]
          for (local p=0; p<devs.len();p++)
              for (local d=0; d<devs[p][1].len();d++)
                  if( devs[p][1][d] == deviceId)
                  {
                    // Load the required script file
                    noticef("STmicro script : %s\n", devs[p][0])
                    require(devs[p][0])
                    // Call the generic entry point of that script
                    stm32_device()
                    return
                  }
          break
      }

    // ---------- Not supported ChipId yet -----------
    throw ERROR_NOT_FOUND
}

/////////////////////////////////////////////////////////////////////////////////
//
// Additional commands after reset (optional) called by EBlink
//
// resetType:
//        SYSTEM_RESET
//        CORE_RESET
//        JTAG_RESET
//        USER_RESET
//
function  reset_post(resetType)
{
    // Check if there is an user defined post reset hook, the user
    // can add his own reset strategy with -S <myscript> as last
    // defined script on the cli.
    if (isScriptObject("reset_post_hook"))
        return reset_post_hook(resetType);

    // We don't use this if the reset is a user_script type. In that
    // case, the user is responsible for the initialization.
    //
    if( resetType != USER_RESET )
    {
        // Set the Stack pointer according the Vector table entry
        intrfApi.readMem32(0x08000000)
        targetApi.writeReg("SP", intrfApi.value32)

        // Set the Program pointer according the Vector table entry
        intrfApi.readMem32(0x08000004)
        targetApi.writeReg("PC", intrfApi.value32)
    }

    return ERROR_OK
}


