/////////////////////////////////////////////////////////////////////////////////
//
//                   Renesas RV40 flash unit
//
//  With the cli define  "-D FLASH_DATA" the data flash is also cleared and programmed
//

const FLASH_TIMEOUT   2000 // Generic 2sec flash timeout

const CMD_REG           0x407E0000
//---------------------------------
const CMD_PROGRAM       0xE8
const CMD_PROGRAM_CF    0x80
const CMD_PROGRAM_DF    0x02
const CMD_BLOCK_ERASE   0x20
const CMD_PE_SUSPEND    0xB0
const CMD_PE_RESUME     0xD0
const CMD_STATUS_CLEAR  0x50
const CMD_FORCED_STOP   0xB3
const CMD_BLANK_CHECK   0x71
const CMD_CONFIG_SET_1  0x40
const CMD_CONFIG_SET_2  0x08
const CMD_LOCK_BIT_PGM  0x77
const CMD_LOCK_BIT_READ 0x71
const CMD_FINAL         0xD0


const BASE_REG 0x407FE000
//--------------------------------------------------
const FASTAT_OFFS    0x10     // Flash Access Status
const FASTAT_CMDLK   (1 << 4) // Command Lock

const FSTATR_OFFS      0x80      // Flash Status
const FSTATR_FLWEERR   (1 <<  6) // Flash Write/Erase Protect Error Flag
const FSTATR_PRGSPD    (1 <<  8) // Programming Suspend Status Flag
const FSTATR_ERSSPD    (1 <<  9) // Erasure Suspend Status Flag
const FSTATR_DBFULL    (1 << 10) // Data Buffer Full
const FSTATR_RDY       (1 << 15) // Flash Ready
const FSTATR_PRGERR    (1 << 12) // Programming Error
const FSTATR_ERSERR    (1 << 13) // Erasure Error
const FSTATR_ILGLERR   (1 << 14) // Illegal Command Error
const FSTATR_OTERR     (1 << 20) // Other Error
const FSTATR_SECERR    (1 << 21) // Security Error
const FSTATR_FESETERR  (1 << 22) // FENTRY Setting Error
const FSTATR_ILGCOMERR (1 << 23) // Illegal Command Error

const FSADDR_OFFS     0x30

const FMEPROT_OFFS    0x44
const FMEPROT_LOCK    0xD901
const FMEPROT_UNLOCK  0xD900

const FENTRYR_OFFS    0x84
const FENTRYR_KEY     (0xAA << 8)
const FENTRYR_PE_CF   1
const FENTRYR_PE_DF   (1 << 7)

const FCPSR_OFFS     0xE0
const FCPSR_ESUSPMD  1

const FWEPROR_REG    0x4001E416

// PE mode related variables
enum peMode {
    READ_PE,
    CODE_PE,
    DATA_PE
}

maxFlashSpeed   <- 4000 // 4MHz is max speed for direct programming (we think)

// Generic Flash Script errors
require("renesas/flash/errors.script")

/////////////////////////////////////////////////////////////////////////////////
//
//   Unlock the flash
//
function flash_start()
{
    // Override the maximum flash speed from cli
    if (isScriptObject("FLASH_SPEED") && FLASH_SPEED>0){
        maxFlashSpeed = FLASH_SPEED
        printf("Flash speed set: %d KHz\n", maxFlashSpeed)
    }

    // Check that we don't go faster than the user selected on the cli
    if(maxFlashSpeed > intrfApi.getSpeed())
        maxFlashSpeed = intrfApi.getSpeed()

    try{
        // Be sure that the core is halted and all clocks are reset
        _n_throw( targetApi.reset(SYSTEM_RESET) )

        // Wait for halt
        local time = GetTickCount();
        do{
            _n_throw( targetApi.poll() )
          // Timeout of 1sec
            if(GetTickCount() - time > 1000)
              _n_throw(ERROR_TIMEOUT)
        } while(targetApi.getState() != TARGET_HALTED )

        // Permit programming and erasing
        _n_throw(intrfApi._readMem(FWEPROR_REG,8))
        while(intrfApi.value32 != 1) {
          _n_throw(intrfApi._writeMem(FWEPROR_REG, 1,8))
          _n_throw(intrfApi._readMem(FWEPROR_REG,8))
        }

        return ERROR_OK
    }

    // Catch all the sector write errors
    catch(e){
       if(e < ERROR_NOTIFIED)
           errorf("Error unlocking flash! %s\n", flashError(e) )
       return ERROR_NOTIFIED
    }
}

/////////////////////////////////////////////////////////////////////////////////
//
//   Erase sequence according ST user manual
//
function flash_erase(sector, address)
{
    if(sector < 1000)
        switchPeMode(peMode.CODE_PE)
    else {
        if(!isScriptObject("FLASH_DATA"))
            return ERROR_OK
        switchPeMode(peMode.DATA_PE)
    }

    try{
        _n_throw(intrfApi._writeMem(BASE_REG+FCPSR_OFFS, FCPSR_ESUSPMD, 16))
        _n_throw(intrfApi.writeMem32(BASE_REG+FSADDR_OFFS, address))

        _n_throw(intrfApi._writeMem(CMD_REG, CMD_BLOCK_ERASE,8))
        _n_throw(intrfApi._writeMem(CMD_REG, CMD_FINAL,8))
        checkBusy(1100)
        error_check(FSTATR_ERSERR | FSTATR_ILGLERR)
        return ERROR_OK
    }

    // Catch all the sector erase errors
    catch(e){
       if(e < ERROR_NOTIFIED)
           errorf("ERROR: erasing sector %d failed! %s\n", sector, flashError(e) )
    }

    return ERROR_NOTIFIED
}



/////////////////////////////////////////////////////////////////////////////////
//
//  The length is always equals to the page to be programmed in bytes because trim is
//  set off by parent script.
//
function flash_write(sector, address, buffer)
{
    local writeSize
    if(sector < 1000) {
        switchPeMode(peMode.CODE_PE)
        writeSize = 0x80
    } else {
        if(!isScriptObject("FLASH_DATA"))
            return ERROR_OK
        // Data flash
        switchPeMode(peMode.DATA_PE)
        writeSize = 0x04
    }

    buffer.trim(writeSize)
    local len = buffer.trimmedSize()
    local idx = 0
    try{
        while(len)
        {
           if( writeSize > len)
               writeSize = len

            _n_throw(intrfApi.writeMem32(BASE_REG+FSADDR_OFFS, address))
            address += writeSize

            _n_throw(intrfApi._writeMem(CMD_REG, CMD_PROGRAM, 8))
            _n_throw(intrfApi._writeMem(CMD_REG, writeSize/2, 8))

            for (local i= 0; i < (writeSize/2); i++) {
                _n_throw(intrfApi._writeMem(CMD_REG, buffer.un16(idx),16))
                idx += 2
                len -= 2
            }

            _n_throw(intrfApi._writeMem(CMD_REG, CMD_FINAL,8))
            checkBusy(1000)
        }
        error_check(FSTATR_PRGERR  | FSTATR_ILGLERR)
        return ERROR_OK
    }

    // Catch all the sector write errors
    catch(e){
       if(e < ERROR_NOTIFIED)
           errorf("ERROR: writing sector %d failed! %s\n", sector, flashError(e) )
       return ERROR_NOTIFIED
    }
}

/////////////////////////////////////////////////////////////////////////////////
//
//
//
function flash_done()
{
    try{
        _n_throw( targetApi.reset(SYSTEM_RESET) )
        
     /*
        switchPeMode(peMode.READ_PE)

        // Prohibit programming and erasing
       _n_throw(intrfApi._readMem(FWEPROR_REG,8))
        while(intrfApi.value32 != 2) {
          _n_throw(intrfApi._writeMem(FWEPROR_REG, 2,8))
          _n_throw(intrfApi._readMem(FWEPROR_REG,8))
        }
     */
        return ERROR_OK
    }

    catch(e){
       if(e < ERROR_NOTIFIED)
           errorf("Error locking flash!\n")
       return ERROR_NOTIFIED
    }
}


/////////////////////////////////////////////////////////////////////////////////
//
//
//
function checkBusy(timeout)
{
    local time = GetTickCount()
    do{
        if(GetTickCount() - time > timeout)
            _n_throw(ERROR_TIMEOUT)
        _n_throw( intrfApi.readMem32(BASE_REG+FSTATR_OFFS) )
    }while ( !(intrfApi.value32 & FSTATR_RDY) )
}

/////////////////////////////////////////////////////////////////////////////////
//
//
//
function error_check(errors)
{
   _n_throw( intrfApi.readMem32(BASE_REG+FSTATR_OFFS) )
   local status = intrfApi.value32

   _n_throw(intrfApi._readMem(BASE_REG+FASTAT_OFFS, 8))

   if( intrfApi.value32 & FASTAT_CMDLK){
        printf("Recovery from the Command-Locked State\n")
       if(status & FSTATR_ILGLERR){
            printf("If an illegal error occurred read and clear CFAE and DFAE in FASTAT\n")
           _n_throw(intrfApi._readMem(BASE_REG+FASTAT_OFFS, 8))
           _n_throw(intrfApi._writeMem(BASE_REG+FASTAT_OFFS, 0, 8))
           checkBusy(20)
         }
   }

   if(status & errors){
       _n_throw(intrfApi._writeMem(CMD_REG, CMD_FORCED_STOP, 8))
       throw -2
   }
}

/////////////////////////////////////////////////////////////////////////////////
//
//   Switch from PE mode
//
function switchPeMode(mode)
{
    _n_throw(intrfApi._readMem(BASE_REG+FENTRYR_OFFS, 16))

    switch(mode){
        case peMode.CODE_PE:
           if(intrfApi.value32 == FENTRYR_PE_CF)
               return
           break
        case peMode.DATA_PE:
           if(intrfApi.value32 == FENTRYR_PE_DF)
               return
           break
        default:
            if(intrfApi.value32 == 0)
                return
            checkBusy(1000)
    }

    _n_throw(intrfApi._writeMem(BASE_REG+FMEPROT_OFFS, FMEPROT_UNLOCK, 16))

    // If we switch from flash modes we have to go via read mode
    if( mode && intrfApi.value32){
        checkBusy(100)
       _n_throw(intrfApi._writeMem(BASE_REG+FENTRYR_OFFS, FENTRYR_KEY, 16))
    }

    local fev = 0
    switch(mode){
        case peMode.CODE_PE:
           fev = FENTRYR_PE_CF
           break
        case peMode.DATA_PE:
           fev = FENTRYR_PE_DF
           break
        default:
            checkBusy(100)
    }

    _n_throw(intrfApi._writeMem(BASE_REG+FENTRYR_OFFS, FENTRYR_KEY | fev, 16))

    local time = GetTickCount()
    do{
        if(GetTickCount() - time > 2000)
            _n_throw(ERROR_TIMEOUT)

        _n_throw(intrfApi._readMem(BASE_REG+FENTRYR_OFFS, 16))
    }while(intrfApi.value32 != fev)

    if(fev == 0)
        _n_throw(intrfApi._writeMem(BASE_REG+FMEPROT_OFFS, FMEPROT_LOCK, 16))

    error_check(FSTATR_ILGLERR)
}
